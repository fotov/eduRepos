//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Предназначен для работы с командными оболочками
//////////////////////////////////////////////////////////////////////////////////////////////////////////
#Если Не ВебКлиент Тогда

#Область ПрограммныйИнтерфейс

// Выполняет команды в выбранной командной оболочке.
// Позволяет также получать код возврата и значения потоков вывода (stdout) и ошибок (stderr)
// Параметры:
//  МассивКоманд		 - Массив		 - массив строк команд для выполнения. Выполняются последовательно
//  ТипОболочки			 - Строка		 - значение из структуры ТипShell()
//  ПараметрыВыполнения	 - Структура	 - см. КонструкторПараметровВыполненияСкрипта()
//    *ТекущийКаталог - Строка - При передаче, перехоит в указанное расположение, если это возможно.
//    *ДождатьсяЗавершения - признак того, что необходимо ожидать завершения работы скрипта.
//        Если ИспользоватьКонтрольВыполнения = Истина, то ДождатьсяЗавершения игнорируется, и эквивалентно значению истина.
//    *ИспользоватьКонтрольВыполнения - скрипт выполняется в оболочке с контролем выполнения.
//        В случае использования этого варианта выполнения: Таймаут на выполнение скрипта используется всегда.
//        Таймаут устанавливается для общего времени выполнения скрипта и получения потоков.
//    *ИспользоватьТаймаутПолученияПотоков - при превышении таймаута прерывать получение потоков. Только при исполнении с контролем, и
//        только для данных, получаемых из запускающей оболочки. Потоки в вызывающей оболочке получаются не зависимо от параметра ПолучитьПоток...,
//        но при включенном сборе потоков происходит перенаправление, и потоки вызывающей оболочки при штатном выполнении - пустые.
//    *Таймаут - Число - указывается в секундах. Устанавливается для общего времени: выполнения и получения данных потоков вывода и ошибок
//    *ИспользоватьКонтрольБезопасностиКоманд - проверять каждую команду из переданного массива отдельно на безопасность.
//    *ПолучитьПотокВывода
//    *ПолучитьПотокОшибок
//    *КодировкаПотоков - см. ЧтениеТекста параметр Кодировка
//    *КодировкаИсполнения - 
//      Для CMD:
//              - Строка
//              - Число - кодировка, устанавливаемая в Windows с помощью команды chcp,
//                возможные значения: "OEM", "CP866", "UTF8" или номер кодовой страницы.
//      Для PowerShell
//              - Строка - см. документацию командного интерпретатора.
//                В случае указания кодировки - выполняется 
//                [Console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('<ВыбраннаяКодировка>')
// 
// Возвращаемое значение:
//  Структура - см. КонструкторРезультатаВыполненияСкрипта()
//    *КодВозврата - Строка, Число
//    *ПотокВывода - Строка
//    *ПотокОшибок - Строка
//
// ======================================================================================================================
//	// Кодировка на сервере:
//	// При получении текущего значения из PowerShell - utf8.
//	// При этом в файлы после записи перенаправленных потоков (в команде PowerShell) - редактор отображает кодировку UTF-16.
//	// При преобразовании из UTF-16 не удалось определить, в какую кодировку нужно преобразовать для корректного отображения
//	// методом ПреобразоватьКодировку().
//	// Чтение текста из файла отображает корректно кириллицу при чтении с кодировками ANSI и UTF-16 и Неопределено в 1С,
//	// при этом в редакторе (Notepad++) корректно отображается только с кодировками UTF-16 и UTF-8.
//	// Из документации PowerShell:
//	// Для командлетов, которые записывают выходные данные в файлы:
//	//  Out-File и операторы > перенаправления и >> создание UTF-16LE, которые, в частности, отличаются от Set-Content и Add-Content.
//	//
//	// Для получения логов в текущий момент устанавливается в конструкторе по умолчанию кодировка Неопределено.
//	// Поэтому, предполагаю, что ЧтениеТекста определяет кодировку автоматически на основании BOM.
//	// 
//	// Для CMD проверки не выполнялись. При этом при формировании скрипта первой командой устанавливается UTF8 (65001)
//	
//	// Для оболочки, используемой, как обёртка WScript.Shell - нет возможности установить кодировку,
//	// поэтому кириллица при чтении из потоков и записи в файл - искажается.
//	// Таким образом, для получения информации из стандартных потоков,
//	// необходимо добавлять команды в вызываемом скрипте (внутри кавычек, обрамляющих блок команд, но за блоком).
// ======================================================================================================================
//
// Пример:
//	// Простой запуск
//	ТипОболочки = КоманднаяОболочкаКлиентСервер.ТипShell();
//	МассивКоманд = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("ping 127.0.0.1");
//	КоманднаяОболочкаКлиентСервер.ВыполнитьСкрипт(МассивКоманд, ТипОболочки);
//
//	// Запуск с настройкой параметров
//	МассивКоманд = Новый Массив;
//	МассивКоманд.Добавить("[Console]::OutputEncoding");
//
//	ПараметрыВыполнения = КоманднаяОболочкаКлиентСервер.КонструкторПараметровВыполненияСкрипта();
//	ПараметрыВыполнения.Вставить("ИспользоватьТаймаутПолученияПотоков", Истина);
//	ПараметрыВыполнения.Вставить("Таймаут", 10);
//	ПараметрыВыполнения.Вставить("ТекущийКаталог", "\\izb-fs05\Automacons\");
//
//	ТипОболочки = КоманднаяОболочкаКлиентСервер.ТипShell().PowerShell;
//
//	Результат = КоманднаяОболочкаКлиентСервер.ВыполнитьСкрипт(МассивКоманд,ТипОболочки, ПараметрыВыполнения);
//	ОбщегоНазначения.СообщитьПользователю(СтрШаблон("Вывод: %1" "Ошибки: %2", Результат.ПотокВывода, Результат.ПотокОшибок));
//
Функция ВыполнитьСкрипт(МассивКоманд, ТипОболочки, ПараметрыВыполнения = Неопределено) Экспорт
	
	Если ПараметрыВыполнения = Неопределено Тогда
		ПараметрыВыполнения = КонструкторПараметровВыполненияСкрипта();
	КонецЕсли;
	
	ПараметрыВыводаПотоков = Новый Структура;
	ПараметрыВыводаПотоков.Вставить("ИмяФайлаПотокаВывода", "");
	ПараметрыВыводаПотоков.Вставить("ИмяФайлаПотокаОшибок", "");
	
	Если ПараметрыВыполнения.ПолучитьПотокВывода Тогда 
		ПараметрыВыводаПотоков.ИмяФайлаПотокаВывода = ПолучитьИмяВременногоФайла("stdout.tmp");
	КонецЕсли;
	Если ПараметрыВыполнения.ПолучитьПотокОшибок Тогда 
		ПараметрыВыводаПотоков.ИмяФайлаПотокаОшибок = ПолучитьИмяВременногоФайла("stderr.tmp");
	КонецЕсли;
	
	ТекстСкрипта = ПолучитьТекстСкрипта(МассивКоманд, ТипОболочки, ПараметрыВыполнения, ПараметрыВыводаПотоков);
	
	Если ПараметрыВыполнения.ИспользоватьКонтрольВыполнения Тогда
		Результат = ВыполнитьСкриптСКонтролемВыполнения(ТекстСкрипта, ТипОболочки, ПараметрыВыполнения);
	Иначе
		Результат = ВыполнитьСкриптБезКонтроляВыполнения(ТекстСкрипта, ТипОболочки, ПараметрыВыполнения);
	КонецЕсли;
	
	Если ПараметрыВыполнения.ПолучитьПотокВывода Тогда
		Результат.ПотокВывода = Результат.ПотокВывода + ПрочитатьФайлЕслиСуществует(ПараметрыВыводаПотоков.ИмяФайлаПотокаВывода, ПараметрыВыполнения.КодировкаПотоков);
		УдалитьФайлЕслиВозможно(ПараметрыВыводаПотоков.ИмяФайлаПотокаВывода);
	КонецЕсли;
	Если ПараметрыВыполнения.ПолучитьПотокОшибок Тогда 
		Результат.ПотокОшибок = Результат.ПотокОшибок + ПрочитатьФайлЕслиСуществует(ПараметрыВыводаПотоков.ИмяФайлаПотокаОшибок, ПараметрыВыполнения.КодировкаПотоков);
		УдалитьФайлЕслиВозможно(ПараметрыВыводаПотоков.ИмяФайлаПотокаОшибок);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Область КонструкторыИСловари

// Конструктор для параметров выполнения скрипта
// см. ВыполнитьСкрипт
// 
// Возвращаемое значение:
//  Структура
//
Функция КонструкторПараметровВыполненияСкрипта() Экспорт
	
	ПараметрыВыполнения = Новый Структура;
	ПараметрыВыполнения.Вставить("ТекущийКаталог", "");
	ПараметрыВыполнения.Вставить("ДождатьсяЗавершения", Истина);
	ПараметрыВыполнения.Вставить("ИспользоватьКонтрольВыполнения", Истина);
	ПараметрыВыполнения.Вставить("ИспользоватьТаймаутПолученияПотоков", Ложь);
	ПараметрыВыполнения.Вставить("Таймаут", 10); // Общий для выполнения скрипта и получения потоков
	
	ПараметрыВыполнения.Вставить("ИспользоватьКонтрольБезопасностиКоманд", Истина);
	ПараметрыВыполнения.Вставить("ПолучитьПотокВывода", Истина);
	ПараметрыВыполнения.Вставить("ПолучитьПотокОшибок", Истина);
	
	ПараметрыВыполнения.Вставить("КодировкаИсполнения", Неопределено);
	ПараметрыВыполнения.Вставить("КодировкаПотоков", Неопределено);
	
	Возврат ПараметрыВыполнения;
	
КонецФункции

// Словарь - перечисление типа командной оболочки
// 
// Возвращаемое значение:
//   - Структура
//      *PowerShell
//      *CMD
//      *bash
//
Функция ТипShell() Экспорт
	Перечисление = Новый Структура;
	Перечисление.Вставить("PowerShell", "PowerShell");
	Перечисление.Вставить("CMD", "CMD");
	Перечисление.Вставить("bash", "bash");
	
	Возврат Новый ФиксированнаяСтруктура(Перечисление);
КонецФункции

#КонецОбласти

#Область ШаблоныКоманд

// Команда изменения текущего каталога.PowerShell
//
// Параметры:
//  ПутьККаталогу	 - 	Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ТекстКоманды_ИзменитьКаталогPS(ПутьККаталогу) Экспорт
	Возврат СтрШаблон("Set-Location %1", ПутьККаталогу);
КонецФункции

// Команда изменения Кодировки.PowerShell
//
// Параметры:
//  Кодировка	 - 	Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ТекстКоманды_ИзменитьКодировкуPS(Кодировка) Экспорт
	// ещё возможен вариант: "[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8"
	Возврат СтрШаблон("[Console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('%1')", Кодировка);
КонецФункции

// Команда получения Кодировки.PowerShell
//
// Параметры:
//  Кодировка	 - 	Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ТекстКоманды_ПрочитатьКодировкуPS() Экспорт
	// ещё возможен вариант: "[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8"
	Возврат "[Console]::OutputEncoding";
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция КонструкторРезультатаВыполненияСкрипта()
	
	Конструктор = Новый Структура;
	Конструктор.Вставить("КодВозврата", 0);
	Конструктор.Вставить("ПотокВывода", "");
	Конструктор.Вставить("ПотокОшибок", "");
	
	Возврат Конструктор;
	
КонецФункции

// Выполняет скрипт с использованием WScript.Shell
// Возможен контроль времени выполнения и получение потоков вывода и ошибок.
//
// Параметры:
//  ТекстСкрипта		 - Строка
//  ТипОболочки			 - Строка	 - см. ТипShell()
//  ПараметрыВыполнения	 - Структура	 - см. КонструкторПараметровВыполненияСкрипта()
// 
// Возвращаемое значение:
//  Структура - см. КонструкторРезультатаВыполненияСкрипта()
//
Функция ВыполнитьСкриптСКонтролемВыполнения(ТекстСкрипта, ТипОболочки, ПараметрыВыполнения)
	
	РезультатВыполненияСкрипта = КонструкторРезультатаВыполненияСкрипта();
	ЗавершитьВыполнениеПосле = ТекущаяДата() + ПараметрыВыполнения.Таймаут;
	
	Попытка
		Оболочка = Новый COMОбъект("WScript.Shell");
	Исключение
		ВызватьИсключение 
			"Не удалось инициализировать WScript.Shell.
			|Подробнее:
			|" + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;

	ОболочкаИсполнитель = Оболочка.Exec(ТекстСкрипта);
	ПотокВывода = ОболочкаИсполнитель.StdOut;
	ПотокОшибок = ОболочкаИсполнитель.StdErr;
	
	КомандаЗавершенаПоТаймауту = Ложь;
	Пока ОболочкаИсполнитель.Status = 0 Цикл
		Если ЗавершитьВыполнениеПосле <= ТекущаяДата() Тогда
			КомандаЗавершенаПоТаймауту = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ПараметрыВыполнения.ИспользоватьТаймаутПолученияПотоков Тогда
		РезультатВыполненияСкрипта.ПотокВывода = ПолучитьВыводПотокаСКонтролем(ПотокВывода, ЗавершитьВыполнениеПосле, КомандаЗавершенаПоТаймауту);
		РезультатВыполненияСкрипта.ПотокОшибок = ПолучитьВыводПотокаСКонтролем(ПотокОшибок, ЗавершитьВыполнениеПосле, КомандаЗавершенаПоТаймауту);
	Иначе
		РезультатВыполненияСкрипта.ПотокВывода = ПотокВывода.ReadAll();
		РезультатВыполненияСкрипта.ПотокОшибок = ПотокОшибок.ReadAll();
	КонецЕсли;
		
	Попытка
		ОболочкаИсполнитель.Terminate();
		ОболочкаИсполнитель = Неопределено;
	Исключение
		// здесь можно завершить порождённый процесс.
		ОболочкаИсполнитель = Неопределено;
	КонецПопытки;	
	Оболочка = Неопределено;
	
	Если КомандаЗавершенаПоТаймауту Тогда
		ВызватьИсключение "Внимание! Выполнение остановлено по истечении времени ожидания.";
	КонецЕсли;
	
	Возврат РезультатВыполненияСкрипта;
	
КонецФункции

// Выполняет скрипт с использованием платформенного метода ЗапуститьПриложение()
//
// Параметры:
//  ТекстСкрипта		 - Строка
//  ТипОболочки			 - Строка	 - см. ТипShell()
//  ПараметрыВыполнения	 - Структура	 - см. КонструкторПараметровВыполненияСкрипта()
// 
// Возвращаемое значение:
//  Структура - см. КонструкторРезультатаВыполненияСкрипта()
//
Функция ВыполнитьСкриптБезКонтроляВыполнения(ТекстСкрипта, ТипОболочки, ПараметрыВыполнения)
	
	Результат = КонструкторРезультатаВыполненияСкрипта();
	КодВозврата = 0;
	
	// При таком запуске некорректно обрабатываются ключи- слеши. Пока используем механизм БСП.
	// Его ограничения - невозможно запустить "небезопасные команды
	//#Если Клиент Тогда
	ЗапуститьПриложение(ТекстСкрипта,, ПараметрыВыполнения.ДождатьсяЗавершения, КодВозврата);
	Результат.КодВозврата = КодВозврата;
	//#Иначе
	//ПараметрыЗапускаПрограммы = ФайловаяСистема.ПараметрыЗапускаПрограммы();
	//ЗаполнитьЗначенияСвойств(ПараметрыЗапускаПрограммы, ПараметрыВыполнения);
	//РезультатЗапускаПрограммы = ФайловаяСистема.ЗапуститьПрограмму(ТекстСкрипта, ПараметрыЗапускаПрограммы); 
	//ЗаполнитьЗначенияСвойств(Результат, РезультатЗапускаПрограммы);
	//#КонецЕсли
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьТекстСкрипта(МассивКоманд, ТипОболочки, ПараметрыВыполнения, ПараметрыВыводаПотоков)
	
	Если ПараметрыВыполнения.ИспользоватьКонтрольБезопасностиКоманд Тогда
		СтрокаКоманды = БезопаснаяСтрокаКоманды(МассивКоманд, ТипОболочки);
	Иначе
		СтрокаКоманды = СтрокаКоманды(МассивКоманд, ТипОболочки);
	КонецЕсли;
	
	ТекстСкрипта = "";
	Если ТипОболочки = ТипShell().PowerShell Тогда
		ТекстСкрипта = СтрокаЗапускаКомандыPowerShell(
			СтрокаКоманды,
			ПараметрыВыполнения.ТекущийКаталог,
			ПараметрыВыводаПотоков,
			ПараметрыВыполнения.КодировкаИсполнения);
	ИначеЕсли ТипОболочки = ТипShell().CMD Тогда
		ТекстСкрипта = СтрокаЗапускаКомандыCMD(
			СтрокаКоманды,
			ПараметрыВыполнения.ТекущийКаталог,
			ПараметрыВыводаПотоков,
			ПараметрыВыполнения.КодировкаИсполнения);
	КонецЕсли;
	
	Если ПустаяСтрока(ТекстСкрипта) Тогда
		ВызватьИсключение "Не удалось сформировать текст скрипта. Неизвестный командный интерпретатор.";
	КонецЕсли;
	
	Возврат ТекстСкрипта;
	
КонецФункции

Функция СтрокаКоманды(МассивКоманд, ТипОболочки, Разделитель = "; ")
	Возврат ?(ТипОболочки = ТипShell().PowerShell, СтрСоединить(МассивКоманд, Разделитель), МассивВСтрокуКоманды(МассивКоманд, Разделитель));
КонецФункции

// Проверяет на безопасность переданную команду, и формирует строку команд в случае передачи массива
// Параметры:
//  КомандаЗапуска - Строка, Массив
// 
// Возвращаемое значение:
//  Строка
//
Функция БезопаснаяСтрокаКоманды(КомандаЗапуска, ТипОболочки, Разделитель = "; ")
	
	Результат = "";
	
	Если ТипЗнч(КомандаЗапуска) = Тип("Строка") Тогда 
		
		ПроверитьСодержитНебезопасныеДействия(КомандаЗапуска);
		Результат = КомандаЗапуска;
		
	ИначеЕсли ТипЗнч(КомандаЗапуска) = Тип("Массив") Тогда
		
		Если КомандаЗапуска.Количество() > 0 Тогда
			ПроверитьСодержитНебезопасныеДействия(КомандаЗапуска[0]);
			Результат = ?(ТипОболочки = ТипShell().PowerShell, СтрСоединить(КомандаЗапуска, Разделитель), МассивВСтрокуКоманды(КомандаЗапуска, Разделитель));
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ожидалось, что первый элемент массива %1 будет командой или путем к исполняемому файлу.'"),
				"КомандаЗапуска");
		КонецЕсли;
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ожидалось, что значение %1 будет типа %2 или %3.'"), 
			"КомандаЗапуска", "Строка", "Массив");
	КонецЕсли;
		
	Возврат Результат
	
КонецФункции

// Формирует строку запуска команды для CMD
//
// Параметры:
//  СтрокаКоманды		 - Строка
//  ТекущийКаталог		 - Строка
//  ПараметрыВыводаПотоков	 - Структура - имена файлов для записи стандартных потоков
//    *ИмяФайлаПотокаВывода
//    *ИмяФайлаПотокаОшибок
//  КодировкаИсполнения	 - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция СтрокаЗапускаКомандыCMD(Знач СтрокаКоманды, ТекущийКаталог, ПараметрыВыводаПотоков, КодировкаИсполнения = "UTF8")
	
	НаборКоманд = Новый Массив;
	
	Если ЗначениеЗаполнено(КодировкаИсполнения) Тогда 
		КодировкаИсполнения = ВРег(КодировкаИсполнения);
		
		Если КодировкаИсполнения = "CP866" Тогда
			КодировкаИсполнения = 866;
		ИначеЕсли КодировкаИсполнения = "OEM" Тогда
			КодировкаИсполнения = 437;
		ИначеЕсли КодировкаИсполнения = "UTF8" Тогда
			КодировкаИсполнения = 65001;
		КонецЕсли;
		
		НаборКоманд.Добавить("(chcp " + Формат(КодировкаИсполнения, "ЧГ=") + ")");
	КонецЕсли;
	
	Если Не ПустаяСтрока(ТекущийКаталог) Тогда 
		НаборКоманд.Добавить("(cd /D """ + ТекущийКаталог + """)");
	КонецЕсли;
	
	Если Не ПустаяСтрока(ПараметрыВыводаПотоков.ИмяФайлаПотокаВывода) Тогда 
		СтрокаКоманды = СтрокаКоманды + " > " + ПараметрыВыводаПотоков.ИмяФайлаПотокаВывода;
	КонецЕсли;
	Если Не ПустаяСтрока(ПараметрыВыводаПотоков.ИмяФайлаПотокаОшибок) Тогда 
		СтрокаКоманды = СтрокаКоманды + " 2> " + ПараметрыВыводаПотоков.ИмяФайлаПотокаОшибок;
	КонецЕсли;
	
	НаборКоманд.Добавить(СтрокаКоманды);
	
	Возврат СтрШаблон("cmd /S /C ""%1""", СтрСоединить(НаборКоманд, "&&"));
	
КонецФункции

// Формирует строку запуска команды для PowerShell
//
// Параметры:
//  СтрокаКоманды		 - Строка
//  ТекущийКаталог		 - Строка
//  ПараметрыВыводаПотоков	 - Структура - имена файлов для записи стандартных потоков
//    *ИмяФайлаПотокаВывода
//    *ИмяФайлаПотокаОшибок
//  КодировкаИсполнения	 - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция СтрокаЗапускаКомандыPowerShell(СтрокаКоманды, ТекущийКаталог, ПараметрыВыводаПотоков, КодировкаИсполнения = "")
	
	НаборКоманд = Новый Массив;
	
	Если ЗначениеЗаполнено(КодировкаИсполнения) Тогда
		НаборКоманд.Добавить(СтрШаблон("[Console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('%1')", КодировкаИсполнения));
	КонецЕсли;
	
	Если Не ПустаяСтрока(ТекущийКаталог) Тогда 
		НаборКоманд.Добавить(ТекстКоманды_ИзменитьКаталогPS(ТекущийКаталог));
	КонецЕсли;
	НаборКоманд.Добавить(СтрокаКоманды);
	
	СтрокаВыводаПотоков = "";
	Если Не ПустаяСтрока(ПараметрыВыводаПотоков.ИмяФайлаПотокаВывода) Тогда 
		СтрокаВыводаПотоков = СтрокаВыводаПотоков + " > " + ПараметрыВыводаПотоков.ИмяФайлаПотокаВывода;
	КонецЕсли;
	Если Не ПустаяСтрока(ПараметрыВыводаПотоков.ИмяФайлаПотокаОшибок) Тогда 
		СтрокаВыводаПотоков = СтрокаВыводаПотоков + " 2> " + ПараметрыВыводаПотоков.ИмяФайлаПотокаОшибок;
	КонецЕсли;
	
	Возврат СтрШаблон("PowerShell -ExecutionPolicy Bypass -Command ""&{%1}%2""", СтрСоединить(НаборКоманд, "; "), СтрокаВыводаПотоков);
	
КонецФункции

#Область БезопаснаяСтрокаКоманды

Функция СодержитНебезопасныеДействия(Знач СтрокаКоманды)
	
	Возврат СтрНайти(СтрокаКоманды, "${") <> 0
		Или СтрНайти(СтрокаКоманды, "$(") <> 0
		Или СтрНайти(СтрокаКоманды, "`") <> 0
		Или СтрНайти(СтрокаКоманды, "|") <> 0
		Или СтрНайти(СтрокаКоманды, ";") <> 0
		Или СтрНайти(СтрокаКоманды, "&") <> 0;
	
КонецФункции

Процедура ПроверитьСодержитНебезопасныеДействия(Знач КомандаЗапуска)
	Если СодержитНебезопасныеДействия(КомандаЗапуска) Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Не удалось запустить программу.
			           |Недопустимая строка команды
			           |%1
			           |
			           |Строка команды не должна содержать символы: ""${"", ""$("", ""`"", ""|"", "";"", ""&"".'"),
			КомандаЗапуска);
	КонецЕсли;
КонецПроцедуры

// Для CMD. В случае PowerShell вызывает ошибку, т.к. расставляет кавычки, а PS не понимает их.
Функция МассивВСтрокуКоманды(КомандаЗапуска, Разделитель)
	
	Результат = Новый Массив;
	НужныКавычки = Ложь;
	Для Каждого Аргумент Из КомандаЗапуска Цикл
		
		Если Результат.Количество() > 0 Тогда 
			Результат.Добавить(Разделитель)
		КонецЕсли;
		
		НужныКавычки = Аргумент = Неопределено
			Или ПустаяСтрока(Аргумент)
			Или СтрНайти(Аргумент, " ")
			Или СтрНайти(Аргумент, Символы.Таб)
			Или СтрНайти(Аргумент, "&")
			Или СтрНайти(Аргумент, "(")
			Или СтрНайти(Аргумент, ")")
			Или СтрНайти(Аргумент, "[")
			Или СтрНайти(Аргумент, "]")
			Или СтрНайти(Аргумент, "{")
			Или СтрНайти(Аргумент, "}")
			Или СтрНайти(Аргумент, "^")
			Или СтрНайти(Аргумент, "=")
			Или СтрНайти(Аргумент, ";")
			Или СтрНайти(Аргумент, "!")
			Или СтрНайти(Аргумент, "'")
			Или СтрНайти(Аргумент, "+")
			Или СтрНайти(Аргумент, ",")
			Или СтрНайти(Аргумент, "`")
			Или СтрНайти(Аргумент, "~")
			Или СтрНайти(Аргумент, "$")
			Или СтрНайти(Аргумент, "|");
		
		Если НужныКавычки Тогда 
			Результат.Добавить("""");
		КонецЕсли;
		
		Результат.Добавить(СтрЗаменить(Аргумент, """", """"""));
		
		Если НужныКавычки Тогда 
			Результат.Добавить("""");
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрСоединить(Результат);
	
КонецФункции

#КонецОбласти

Процедура ЗаписатьТекстВФорматеUTF8безBOM(Текст, ПолноеИмяФайла)

	// У УстановитьТелоИзСтроки есть 3й параметр ИспользованиеByteOrderMark.
	// Можно его явно поставить в ЛОЖЬ, но судя по доке значение по умолчанию "Авто".
	// Для этого параметра для кодировки UTF-8 принимает значение "Не использовать",
	// поэтому экономим лишние символы =) 
	
	Запрос = Новый HTTPЗапрос();
	Запрос.УстановитьТелоИзСтроки(Текст, КодировкаТекста.UTF8);
	ДвоичныеДанные=Запрос.ПолучитьТелоКакДвоичныеДанные();
	ДвоичныеДанные.Записать(ПолноеИмяФайла);
	
КонецПроцедуры

Функция ПреобразоватьКодировку(Текст, ИсходнаяКодировка = "UTF16", НоваяКодировка = "windows-1251") Экспорт
	
	ВременныйФайлИсходный = ПолучитьИмяВременногоФайла();
	
	ЗаписьТекстаИсходный = Новый ТекстовыйДокумент;
	ЗаписьТекстаИсходный.УстановитьТекст(Текст);
	ЗаписьТекстаИсходный.Записать(ВременныйФайлИсходный, ИсходнаяКодировка);
	
	ЧтениеТекстаНовый = Новый ТекстовыйДокумент;
	ЧтениеТекстаНовый.Прочитать(ВременныйФайлИсходный, НоваяКодировка); 
	КонвертированныйТекст = ЧтениеТекстаНовый.ПолучитьТекст();
	
	УдалитьФайлЕслиВозможно(ВременныйФайлИсходный);
	
	Возврат КонвертированныйТекст;
	
КонецФункции

Функция ПрочитатьФайлЕслиСуществует(Путь, Кодировка)
	
	Результат = Неопределено;
	ФайлИнфо = Новый Файл(Путь);
	
	Если ФайлИнфо.Существует() Тогда 
		
		ЧтениеПотокаОшибок = Новый ЧтениеТекста(Путь, Кодировка);
		Результат = ЧтениеПотокаОшибок.Прочитать();
		ЧтениеПотокаОшибок.Закрыть();
		
	КонецЕсли;
	
	Если Результат = Неопределено Тогда 
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция УдалитьФайлЕслиВозможно(ПутьКФайлу)
	
	Если НЕ ЗначениеЗаполнено(ПутьКФайлу) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ПутьКФайлу);
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

Функция ПолучитьВыводПотокаСКонтролем(Поток, ЗавершитьВыполнениеПосле, КомандаЗавершенаПоТаймауту)
	
	СтрокиПотока = Новый Массив;
	
	Пока Не Поток.AtEndOfStream Цикл
		СтрокиПотока.Добавить(Поток.ReadLine());
		Если ЗавершитьВыполнениеПосле <= ТекущаяДата() Тогда
			КомандаЗавершенаПоТаймауту = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	
	Возврат СтрСоединить(СтрокиПотока, Символы.ПС);
	
КонецФункции

#КонецОбласти
#КонецЕсли